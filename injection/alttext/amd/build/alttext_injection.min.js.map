{"version":3,"file":"alttext_injection.min.js","sources":["../src/alttext_injection.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Ultra-optimized AI Alt Text injection for Tiny Media modals.\n *\n * @module     aiinjection_alttext/alttext_injection\n * @copyright  2025 ISB Bayern\n * @author     Dr. Peter Mayer\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Log from 'core/log';\nimport {getString} from 'core/str';\nimport {alert as moodleAlert} from 'core/notification';\nimport {makeRequest} from 'local_ai_manager/make_request';\nimport Templates from 'core/templates';\n\n/** @type {WeakSet} Track modals that have been initialized to prevent duplicate listeners */\nconst initializedModals = new WeakSet();\n\n/** @type {Object|null} Store AI configuration passed from PHP */\nlet aiConfig = null;\n\n/**\n * Get current user language from DOM.\n *\n * Extracts the language from the html lang attribute which is set by Moodle.\n * Falls back to 'English' if not found.\n *\n * @returns {string} User's current language name\n */\nconst getCurrentLanguage = () => {\n    const htmlLang = document.documentElement.lang || 'en';\n    // Map common language codes to full language names for the AI prompt.\n    const languageMap = {\n        'de': 'German',\n        'en': 'English',\n        'fr': 'French',\n        'es': 'Spanish',\n        'it': 'Italian',\n        'pt': 'Portuguese',\n        'nl': 'Dutch',\n        'pl': 'Polish',\n        'ru': 'Russian',\n        'ja': 'Japanese',\n        'zh': 'Chinese',\n        'ko': 'Korean',\n        'ar': 'Arabic',\n        'tr': 'Turkish',\n        'cs': 'Czech',\n        'sv': 'Swedish',\n        'da': 'Danish',\n        'fi': 'Finnish',\n        'no': 'Norwegian',\n        'hu': 'Hungarian',\n        'el': 'Greek',\n        'he': 'Hebrew',\n        'uk': 'Ukrainian',\n    };\n    // Extract base language code (e.g., 'de' from 'de-DE').\n    const baseLang = htmlLang.split('-')[0].toLowerCase();\n    return languageMap[baseLang] || 'English';\n};\n\n/**\n * Check if AI purpose is disabled.\n *\n * @returns {boolean} True if purpose is disabled\n */\nconst isPurposeDisabled = () => {\n    if (!aiConfig?.purposes?.[0]) {\n        return false;\n    }\n    return aiConfig.purposes[0].available === 'disabled';\n};\n\n/**\n * Get disabled reason message.\n *\n * @returns {string|null} Disabled reason or null\n */\nconst getDisabledReason = () => {\n    if (!isPurposeDisabled()) {\n        return null;\n    }\n    return aiConfig.purposes[0].disabledreason || null;\n};\n\n/**\n * Convert image to base64 using fetch and FileReader.\n *\n * Uses fetch to retrieve the image as a blob and FileReader to convert to base64.\n * This approach avoids canvas CORS issues and is more reliable for cross-origin images.\n *\n * @param {string} imageUrl Image URL to convert\n * @returns {Promise<string>} Promise resolving to base64 data URL\n */\nconst imageToBase64 = async(imageUrl) => {\n    const response = await fetch(imageUrl);\n    if (!response.ok) {\n        throw new Error('Failed to fetch image');\n    }\n    const blob = await response.blob();\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = () => reject(new Error('FileReader failed'));\n        reader.readAsDataURL(blob);\n    });\n};\n\n/**\n * Display error alert to user.\n *\n * @param {string} message Error message to display\n * @param {string|null} title Optional title for the alert\n */\nconst showErrorAlert = async(message, title = null) => {\n    if (title === null) {\n        title = await getString('generateerror', 'aiinjection_alttext');\n    }\n    await moodleAlert(title, message);\n};\n\n/**\n * Extract alt text from AI response\n *\n * @param {Object} data Response data from AI service\n * @returns {string|null} Extracted alt text or null\n */\nconst extractAltText = (data) => {\n    if (data?.error) {\n        return null;\n    }\n    const result = data?.result || data?.data?.result;\n    if (!result) {\n        return null;\n    }\n\n    // Strip HTML tags from result.\n    let text = result.replace(/<[^>]*>/g, '').trim();\n    // Attempt to decode escaped unicode characters.\n    try {\n        text = JSON.parse('\"' + text.replace(/\"/g, '\\\\\"') + '\"');\n    } catch (e) {\n        // Use original if JSON parsing fails.\n    }\n    return text || null;\n};\n\n/**\n * Generate alt text using AI service\n *\n * @param {string} imageUrl Image URL to process\n * @returns {Promise<string|null>} Generated alt text or null\n */\nconst generateAltText = async(imageUrl) => {\n    // Get current user language for the prompt.\n    const currentLanguage = getCurrentLanguage();\n\n    const [imageBase64, prompt] = await Promise.all([\n        imageToBase64(imageUrl),\n        getString('aiprompt', 'aiinjection_alttext', currentLanguage)\n    ]);\n\n    const result = await makeRequest('itt', prompt, 'aiinjection_alttext', 0, {image: imageBase64});\n\n    // Check for error response with code.\n    if (result?.code && result.code !== 200) {\n        const parsedResult = JSON.parse(result.result);\n        if (parsedResult.debuginfo) {\n            Log.error(parsedResult.debuginfo);\n        }\n        throw new Error(parsedResult.message || 'AI request failed');\n    }\n\n    return extractAltText(Array.isArray(result) ? result[0] : result);\n};\n\n/**\n * Button click handler\n *\n * @param {Event} event Click event\n */\nconst handleButtonClick = async(event) => {\n    event.preventDefault();\n    const button = event.target.closest('[data-action=\"generate-alttext\"]');\n    if (!button) {\n        return;\n    }\n    const modal = button.closest(\".modal\");\n    const textarea = modal.querySelector(\".tiny_image_altentry\");\n    const image = modal.querySelector(\".tiny_image_preview\");\n\n    if (!textarea || !image?.src || image.src === \"data:,\") {\n        return;\n    }\n\n    // Show loading state via template.\n    await injectButton(modal, {isloading: true});\n\n    try {\n        const altText = await generateAltText(image.src);\n        if (altText) {\n            textarea.value = altText;\n            textarea.dispatchEvent(new Event(\"input\", {bubbles: true}));\n            textarea.dispatchEvent(new Event(\"change\", {bubbles: true}));\n        }\n    } catch (error) {\n        Log.error(\"Alt text generation failed:\", error);\n        const errorMessage = await getString('generateerrorwithmessage', 'aiinjection_alttext', error.message);\n        await showErrorAlert(errorMessage);\n    }\n\n    // Reset to normal state via template.\n    await injectButton(modal, {isloading: false});\n};\n\n/**\n * Inject AI button into modal.\n *\n * Uses Templates.appendNodeContents for proper rendering and JS execution.\n * Handles disabled state by showing a disabled button with tooltip.\n *\n * @param {HTMLElement} modal Modal element to inject button into\n * @param {Object} templateContext Context object for template rendering (optional)\n */\nconst injectButton = async(modal, templateContext = {}) => {\n    // Use data attribute selector for the character count element.\n    const countspan = modal.querySelector('[data-region=\"character-count\"]') || modal.querySelector(\"#the-count\");\n    if (!countspan) {\n        return;\n    }\n\n    // Remove existing button if present.\n    const existingButton = modal.querySelector('[data-action=\"generate-alttext\"]');\n    if (existingButton) {\n        existingButton.remove();\n    }\n\n    // Add disabled state to template context if purpose is disabled.\n    if (isPurposeDisabled()) {\n        templateContext.isdisabled = true;\n        templateContext.disabledreason = getDisabledReason();\n    }\n\n    // Render template using Templates.appendNodeContents which handles JS execution.\n    const {html, js} = await Templates.renderForPromise('aiinjection_alttext/ai_button_container', templateContext);\n    countspan.insertAdjacentHTML(\"afterend\", html);\n    Templates.runTemplateJS(js);\n\n    // Only add event listener if not disabled.\n    const button = modal.querySelector('[data-action=\"generate-alttext\"]');\n    if (button && !isPurposeDisabled()) {\n        button.addEventListener('click', handleButtonClick);\n    }\n};\n\n/**\n * Initialize MutationObserver for modal detection.\n *\n * Watches for new modals being added to the DOM and injects the AI button.\n * Uses WeakSet to track initialized modals and prevent duplicate listeners.\n */\nconst initModalObserver = () => {\n    const observer = new MutationObserver((mutations) => {\n        mutations.forEach((mutation) => {\n            mutation.addedNodes.forEach((node) => {\n                if (node.nodeType === Node.ELEMENT_NODE) {\n                    // Check if added node is a modal with tiny_image_altentry.\n                    if (node.classList?.contains('modal') && node.querySelector('.tiny_image_altentry')) {\n                        if (!initializedModals.has(node)) {\n                            initializedModals.add(node);\n                            injectButton(node);\n                        }\n                    }\n                    // Check if added node contains a modal with tiny_image_altentry.\n                    const altentry = node.querySelector?.('.modal .tiny_image_altentry');\n                    if (altentry) {\n                        const modalElement = altentry.closest('.modal');\n                        if (modalElement && !initializedModals.has(modalElement)) {\n                            initializedModals.add(modalElement);\n                            injectButton(modalElement);\n                        }\n                    }\n                }\n            });\n        });\n    });\n\n    observer.observe(document.body, {\n        childList: true,\n        subtree: true\n    });\n};\n\n/**\n * Initialize AI alt text injection.\n *\n * @param {Object} config AI configuration object from PHP\n */\nexport const init = (config) => {\n    // Store configuration for later use.\n    aiConfig = config;\n\n    // Use MutationObserver for detecting dynamically added modals.\n    initModalObserver();\n\n    // Check for existing modals on page load.\n    const existingModals = document.querySelectorAll('.modal .tiny_image_altentry');\n    existingModals.forEach(textarea => {\n        const modal = textarea.closest('.modal');\n        if (modal && !initializedModals.has(modal)) {\n            initializedModals.add(modal);\n            injectButton(modal);\n        }\n    });\n};\n"],"names":["initializedModals","WeakSet","aiConfig","isPurposeDisabled","_aiConfig","purposes","_aiConfig$purposes","available","getDisabledReason","disabledreason","imageToBase64","async","response","fetch","imageUrl","ok","Error","blob","Promise","resolve","reject","reader","FileReader","onload","result","onerror","readAsDataURL","generateAltText","currentLanguage","document","documentElement","lang","split","toLowerCase","imageBase64","prompt","all","image","code","parsedResult","JSON","parse","debuginfo","error","message","data","_data$data","text","replace","trim","e","extractAltText","Array","isArray","handleButtonClick","event","preventDefault","button","target","closest","modal","textarea","querySelector","src","injectButton","isloading","altText","value","dispatchEvent","Event","bubbles","errorMessage","title","showErrorAlert","templateContext","countspan","existingButton","remove","isdisabled","html","js","Templates","renderForPromise","insertAdjacentHTML","runTemplateJS","addEventListener","config","MutationObserver","mutations","forEach","mutation","addedNodes","node","nodeType","Node","ELEMENT_NODE","classList","contains","has","add","altentry","_node$querySelector","modalElement","observe","body","childList","subtree","querySelectorAll"],"mappings":"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"}