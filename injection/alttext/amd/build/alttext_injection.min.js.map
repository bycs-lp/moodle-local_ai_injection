{"version":3,"file":"alttext_injection.min.js","sources":["../src/alttext_injection.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Ultra-optimized AI Alt Text injection for Tiny Media modals.\n *\n * @module     aiinjection_alttext/alttext_injection\n * @copyright  2025 ISB Bayern\n * @author     Dr. Peter Mayer\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Log from 'core/log';\nimport {getString} from 'core/str';\nimport {alert as moodleAlert} from 'core/notification';\nimport {makeRequest} from 'local_ai_manager/make_request';\nimport Templates from 'core/templates';\nimport Popover from 'theme_boost/bootstrap/popover';\nimport {showAiInfo} from 'local_ai_injection/ai_usage_info';\n\n/** @type {WeakSet} Track modals that have been initialized to prevent duplicate listeners */\nconst initializedModals = new WeakSet();\n\n/** @type {Object|null} Store AI configuration passed from PHP */\nlet aiConfig = null;\n\n/** @type {number} Context ID for AI requests, passed from PHP */\nlet contextId = 0;\n\n/** @type {string} Complete prompt from PHP with language already inserted */\nlet prompt = '';\n\n/**\n * Check if AI purpose is disabled.\n *\n * @returns {boolean} True if purpose is disabled\n */\nconst isAiDisabled = () => {\n    if (aiConfig.availability.available === 'disabled') {\n        return true;\n    }\n    if (!aiConfig?.purposes?.[0]) {\n        return false;\n    }\n    return aiConfig.purposes[0].available === 'disabled';\n};\n\n/**\n * Get disabled reason message.\n *\n * @returns {string|null} Disabled reason or null\n */\nconst getDisabledReason = () => {\n    if (!isAiDisabled()) {\n        return null;\n    }\n    if (aiConfig.availability.available === 'disabled') {\n        return aiConfig.availability.errormessage;\n    }\n    return aiConfig.purposes[0].errormessage || null;\n};\n\n/**\n * Convert image to base64 using fetch and FileReader.\n *\n * Uses fetch to retrieve the image as a blob and FileReader to convert to base64.\n * This approach avoids canvas CORS issues and is more reliable for cross-origin images.\n *\n * @param {string} imageUrl Image URL to convert\n * @returns {Promise<string>} Promise resolving to base64 data URL\n */\nconst imageToBase64 = async(imageUrl) => {\n    const response = await fetch(imageUrl);\n    if (!response.ok) {\n        throw new Error('Failed to fetch image');\n    }\n    const blob = await response.blob();\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = () => reject(new Error('FileReader failed'));\n        reader.readAsDataURL(blob);\n    });\n};\n\n/**\n * Display error alert to user.\n *\n * @param {string} message Error message to display\n * @param {string|null} title Optional title for the alert\n */\nconst showErrorAlert = async(message, title = null) => {\n    if (title === null) {\n        title = await getString('generateerror', 'aiinjection_alttext');\n    }\n    await moodleAlert(title, message);\n};\n\n/**\n * Extract alt text from AI response\n *\n * @param {Object} data Response data from AI service\n * @returns {string|null} Extracted alt text or null\n */\nconst extractAltText = (data) => {\n    if (data?.error) {\n        return null;\n    }\n    const result = data?.result || data?.data?.result;\n    if (!result) {\n        return null;\n    }\n\n    // Strip HTML tags from result.\n    let text = result.replace(/<[^>]*>/g, '').trim();\n    // Attempt to decode escaped unicode characters.\n    try {\n        text = JSON.parse('\"' + text.replace(/\"/g, '\\\\\"') + '\"');\n    } catch (e) {\n        // Use original if JSON parsing fails.\n    }\n    return text || null;\n};\n\n/**\n * Generate alt text using AI service\n *\n * @param {string} imageUrl Image URL to process\n * @returns {Promise<string|null>} Generated alt text or null\n */\nconst generateAltText = async(imageUrl) => {\n    const imageBase64 = await imageToBase64(imageUrl);\n\n    const result = await makeRequest('itt', prompt, 'aiinjection_alttext', contextId, {image: imageBase64});\n\n    // Check for error response with code.\n    if (result?.code && result.code !== 200) {\n        const parsedResult = JSON.parse(result.result);\n        if (parsedResult.debuginfo) {\n            Log.error(parsedResult.debuginfo);\n        }\n        throw new Error(parsedResult.message || 'AI request failed');\n    }\n\n    return extractAltText(Array.isArray(result) ? result[0] : result);\n};\n\n/**\n * Button click handler\n *\n * @param {Event} event Click event\n */\nconst handleButtonClick = async(event) => {\n    event.preventDefault();\n    const button = event.target.closest('[data-action=\"generate-alttext\"]');\n    if (!button) {\n        return;\n    }\n    const modal = button.closest(\".modal\");\n    const textarea = modal.querySelector(\".tiny_image_altentry\");\n    const image = modal.querySelector(\".tiny_image_preview\");\n\n    if (!textarea || !image?.src || image.src === \"data:,\") {\n        return;\n    }\n\n    // Show loading state via template.\n    await injectButton(modal, {isloading: true});\n\n    try {\n        const altText = await generateAltText(image.src);\n        if (altText) {\n            textarea.value = altText;\n            textarea.dispatchEvent(new Event(\"input\", {bubbles: true}));\n            textarea.dispatchEvent(new Event(\"change\", {bubbles: true}));\n        }\n    } catch (error) {\n        Log.error(\"Alt text generation failed:\", error);\n        const errorMessage = await getString('generateerrorwithmessage', 'aiinjection_alttext', error.message);\n        await showErrorAlert(errorMessage);\n    }\n\n    // Reset to normal state via template.\n    await injectButton(modal, {isloading: false});\n};\n\n/**\n * Inject AI button into modal.\n *\n * Uses Templates.appendNodeContents for proper rendering and JS execution.\n * Handles disabled state by showing a disabled button with tooltip.\n *\n * @param {HTMLElement} modal Modal element to inject button into\n * @param {Object} templateContext Context object for template rendering (optional)\n */\nconst injectButton = async(modal, templateContext = {}) => {\n    // Use data attribute selector for the character count element.\n    const countspan = modal.querySelector('[data-region=\"character-count\"]') || modal.querySelector(\"#the-count\");\n    if (!countspan) {\n        return;\n    }\n\n    // Remove existing button container if present.\n    const existingContainer = modal.querySelector('.ai-button-container');\n    if (existingContainer) {\n        existingContainer.remove();\n    }\n\n    // Add disabled state to template context if purpose is disabled.\n    if (isAiDisabled()) {\n        templateContext.isdisabled = true;\n        templateContext.disabledreason = getDisabledReason();\n    }\n\n    // Render template using Templates.appendNodeContents which handles JS execution.\n    const {html, js} = await Templates.renderForPromise('aiinjection_alttext/ai_button_container', templateContext);\n    Templates.appendNodeContents(countspan.parentElement, html, js);\n\n    // Initialize popover for disabled button (on wrapper span).\n    const popoverTrigger = countspan.parentElement.querySelector('[data-bs-toggle=\"popover\"]');\n    if (popoverTrigger) {\n        new Popover(popoverTrigger);\n    }\n\n    // Only add event listener if not disabled.\n    const button = modal.querySelector('[data-action=\"generate-alttext\"]');\n    if (button && !isAiDisabled()) {\n        button.addEventListener('click', handleButtonClick);\n    }\n\n    // Add info hint event listener.\n    const info = modal.querySelector('.ai-alttext-info');\n    if (info) {\n        const openInfoModal = () => {\n            showAiInfo('aiinjection_alttext', ['itt']);\n        };\n        info.addEventListener('click', (event) => {\n            event.preventDefault();\n            openInfoModal();\n        });\n        info.addEventListener('keydown', (event) => {\n            if (event.key === ' ') {\n                event.preventDefault();\n                openInfoModal();\n            }\n        });\n    }\n};\n\n/**\n * Initialize MutationObserver for modal detection.\n *\n * Watches for new modals being added to the DOM and injects the AI button.\n * Uses WeakSet to track initialized modals and prevent duplicate listeners.\n */\nconst initModalObserver = () => {\n    const observer = new MutationObserver((mutations) => {\n        mutations.forEach((mutation) => {\n            mutation.addedNodes.forEach((node) => {\n                if (node.nodeType === Node.ELEMENT_NODE) {\n                    // Check if added node is a modal with tiny_image_altentry.\n                    if (node.classList?.contains('modal') && node.querySelector('.tiny_image_altentry')) {\n                        if (!initializedModals.has(node)) {\n                            initializedModals.add(node);\n                            injectButton(node);\n                        }\n                    }\n                    // Check if added node contains a modal with tiny_image_altentry.\n                    const altentry = node.querySelector?.('.modal .tiny_image_altentry');\n                    if (altentry) {\n                        const modalElement = altentry.closest('.modal');\n                        if (modalElement && !initializedModals.has(modalElement)) {\n                            initializedModals.add(modalElement);\n                            injectButton(modalElement);\n                        }\n                    }\n                }\n            });\n        });\n    });\n\n    observer.observe(document.body, {\n        childList: true,\n        subtree: true\n    });\n};\n\n/**\n * Initialize AI alt text injection.\n *\n * @param {Object} config Configuration object from PHP containing aiconfig and contextid\n */\nexport const init = async(config) => {\n    // Store AI configuration for later use.\n    aiConfig = config.aiconfig;\n    // Store context ID for AI requests (required for proper permission checks).\n    contextId = config.contextid || 0;\n    // Store complete prompt from PHP (language already inserted).\n    prompt = config.prompt || '';\n\n    // Use MutationObserver for detecting dynamically added modals.\n    initModalObserver();\n\n    // Check for existing modals on page load.\n    const existingModals = document.querySelectorAll('.modal .tiny_image_altentry');\n    existingModals.forEach(textarea => {\n        const modal = textarea.closest('.modal');\n        if (modal && !initializedModals.has(modal)) {\n            initializedModals.add(modal);\n            injectButton(modal);\n        }\n    });\n};\n"],"names":["initializedModals","WeakSet","aiConfig","contextId","prompt","isAiDisabled","availability","available","_aiConfig","purposes","_aiConfig$purposes","getDisabledReason","errormessage","generateAltText","async","imageBase64","response","fetch","imageUrl","ok","Error","blob","Promise","resolve","reject","reader","FileReader","onload","result","onerror","readAsDataURL","imageToBase64","image","code","parsedResult","JSON","parse","debuginfo","error","message","data","_data$data","text","replace","trim","e","extractAltText","Array","isArray","handleButtonClick","event","preventDefault","button","target","closest","modal","textarea","querySelector","src","injectButton","isloading","altText","value","dispatchEvent","Event","bubbles","errorMessage","title","showErrorAlert","templateContext","countspan","existingContainer","remove","isdisabled","disabledreason","html","js","Templates","renderForPromise","appendNodeContents","parentElement","popoverTrigger","Popover","addEventListener","info","openInfoModal","key","config","aiconfig","contextid","MutationObserver","mutations","forEach","mutation","addedNodes","node","nodeType","Node","ELEMENT_NODE","classList","contains","has","add","altentry","_node$querySelector","modalElement","observe","document","body","childList","subtree","querySelectorAll"],"mappings":"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"}